{
  "name": "bitauth",
  "description": "Passwordless authentication using Bitcoin cryptography",
  "author": {
    "name": "Patrick Nagurny",
    "email": "patrick@bitpay.com"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/bitpay/bitauth.git"
  },
  "contributors": [
    {
      "name": "Eric Martindale",
      "email": "eric@ericmartindale.com"
    },
    {
      "name": "Gordon Hall",
      "email": "gordon@bitpay.com"
    },
    {
      "name": "Braydon Fuller",
      "email": "braydon@bitpay.com"
    }
  ],
  "scripts": {
    "make-dist": "sh scripts/make-dist.sh",
    "postinstall": "npm run make-dist",
    "test": "mocha test/*.js --reporter spec"
  },
  "main": "index.js",
  "version": "0.1.2",
  "dependencies": {
    "elliptic": "^0.15.12",
    "hash.js": "^0.3.2",
    "bs58": "^2.0.0",
    "request": "^2.36.0",
    "express": "^4.3.1",
    "base58-native": "^0.1.4",
    "body-parser": "^1.2.0"
  },
  "devDependencies": {
    "uglify-js": "~2.4.14",
    "browserify": "=6.1.0",
    "chai": "=1.9.1",
    "mocha": "~1.20.1"
  },
  "readme": "BitAuth\n=======\n\nPasswordless authentication using Bitcoin cryptography\n\n# Overview\n\nBitAuth is a way to do secure, passwordless authentication using the cryptography\nin Bitcoin. Instead of using a shared secret, the client signs each request using\na private key and the server checks to make sure the signature is valid and matches\nthe public key.\n\n## Advantages over other authentication mechanisms\n\n* By signing each request, man in the middle attacks are impossible.\n* A nonce is part of the data signed, which prevents replay attacks.\n* The cryptography in Bitcoin is rock solid and is securing billions\n of dollars worth of bitcoins.\n* It uses elliptic curve cryptography which performs much better than RSA.\n* Because the private key is never revealed to the server, it does\nnot need to be exchanged between the server and client over a side channel like\nin HMAC.\n\n## Technical Overview\nBitAuth uses the same technology in Bitcoin. A public private key pair is created\nusing elliptic curve secp256k1. The public SIN (System identification number), \nlike a bitcoin address, is the RIPEMD 160, SHA256 hash of the public key. \nSee https://en.bitcoin.it/wiki/Identity_protocol_v1 for complete details.\n\nIn each request, the client includes a nonce to prevent replay attacks. The client\nsigns the full url with the request body concatenated if there is one. The signature \nis included in the `x-signature` header and the public key is included in the \n`x-identity` header.\n\nThe server verifies that the signature is valid and that it matches the identity (the public key).\nIt then computes the SIN from the public key, and sees whether that SIN has access\nto the requested resource. The nonce is checked to make sure it is higher than \nthe previously used nonce.\n\n## Technology is readily available\n\nWith the growing popularity of Bitcoin, there are already libraries written in\nmany languages. Because BitAuth uses the same technology as Bitcoin, it is easy\nto start using BitAuth.\n\n\n## Problems with password authentication\n\n* Have to keep track of a separate password for every web service. People forget\npasswords, encouraging them to reuse passwords and opening themselves up to \nhaving multiple services compromised.\n* Brute force attacks on weak passwords.\n* Passwords may travel over plaintext\n* Passwords in databases being leaked\n* Phishing attacks to steal passwords\n\n## Passwordless based authentication across web services\n\nWith BitAuth, users can use the same, strong password to encrypt their keys and\nnot worry about one service gaining access to another.\n\nIn the future, an identity system could be built around BitAuth keys where a user\ncould create one key to represent an identity which could authenticate against\nmultiple services. \n\nIn order for this to work, there would have to be a browser \nintegration or plugin which would manage these identities and a Javascript API \nwhere websites could sign requests going to their website with the private key, \nbut without exposing the private key to the third party sites.\n\nThere also needs to be a public place to store SIN's, preferably in\na decentralized blockchain or datastore like namecoin. Key revocations could \nbe stored here as well as reviews/feedback to build a reputation around an \nidentity.\n\n# Getting Started\n\nExample server\n\n```\nvar express = require('express');\nvar bodyParser = require('body-parser');\nvar rawBody = require('../lib/middleware/rawbody');\nvar bitauth = require('../lib/middleware/bitauth');\n\nvar users = {\n  'Tf7UNQnxB8SccfoyZScQmb34V2GdEtQkzDz': {name: 'Alice'},\n  'Tf22EUFxHWh4wmA3sDuw151W5C5g32jgph2': {name: 'Bob'}\n};\n\nvar pizzas = [];\n\nvar app = express();\napp.use(rawBody);\napp.use(bodyParser());\n\n\napp.get('/user', bitauth, function(req, res) {\n  if(!req.sin || !users[req.sin]) return res.send(401, {error: 'Unauthorized'});\n  res.send(200, users[req.sin]);\n});\n\napp.post('/pizzas', bitauth, function(req, res) {\n  if(!req.sin || !users[req.sin]) return res.send(401, {error: 'Unauthorized'});\n  var pizza = req.body;\n  pizza.owner = users[req.sin].name;\n  pizzas.push(pizza);\n  res.send(200, req.body);\n});\n\napp.get('/pizzas', function(req, res) {\n  res.send(200, pizzas);\n});\n\napp.listen(3000);\n```\n\nExample client\n\n```\nvar request = require('request');\nvar bitauth = require('../lib/bitauth');\n\n// These can be generated with bitauth.generateSin()\nvar keys = {\n  alice: '38f93bdda21a5c4a7bae4eb75bb7811cbc3eb627176805c1009ff2099263c6ad',\n  bob: '09880c962437080d72f72c8c63a69efd65d086c9e7851a87b76373eb6ce9aab5'\n};\n\n// GET\n\nfor(k in keys) {\n  var url = 'http://localhost:3000/user';\n  var dataToSign = url;\n  var options = {\n    url: url,\n    headers: {\n      'x-identity': bitauth.getPublicKeyFromPrivateKey(keys[k]),\n      'x-signature': bitauth.sign(dataToSign, keys[k])\n    }\n  };\n\n  request.get(options, function(err, response, body) {\n    if(err) {\n      console.log(err);\n    }\n    if(body) {\n      console.log(body);\n    }\n  });\n}\n\nvar pizzas = ['pepperoni', 'sausage', 'veggie', 'hawaiian'];\n\n// POST\n\nfor(k in keys) {\n  var url = 'http://localhost:3000/pizzas';\n  var data = {type: pizzas[Math.floor(Math.random() * pizzas.length)]};\n  var dataToSign = url + JSON.stringify(data);\n  var options = {\n    url: url,\n    headers: {\n      'x-identity': bitauth.getPublicKeyFromPrivateKey(keys[k]),\n      'x-signature': bitauth.sign(dataToSign, keys[k])\n    },\n    json: data\n  };\n\n  request.post(options, function(err, response, body) {\n    if(err) {\n      console.log(err);\n    }\n    if(body) {\n      console.log(body);\n    }    \n  });\n}\n\n```\n\n## Middleware\nBitAuth exposes a connect middleware for use in connect or ExpressJS applications.  Use:\n```\nvar bitauth = require('bitauth');\napp.use( bitauth.middleware );\n```\n\n## Development\n\nTo build a browser compatible version of BitAuth, run the following command from the project's root directory:\n\n```\nnpm run make-dist\n```\n\nThis will output `bitauth.browser.min.js` to the `dist` directory. The script introduces a global variable at `window.bitauth`.\n\n\nTo then run tests for a web browser open `test/index.html` in a browser, such as:\n\n```bash\nfirefox test/index.html\nchromium-browser test/index.html\n```\n\nTo run tests for Node.js:\n\n```bash\nnpm run test\n```\n",
  "readmeFilename": "README.md",
  "bugs": {
    "url": "https://github.com/bitpay/bitauth/issues"
  },
  "_id": "bitauth@0.1.2",
  "_from": "bitauth@^0.1.1"
}
